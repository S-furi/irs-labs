%!TEX root = ../main.tex
\section{Lab Activity 3}

This laboratory assignment requires to implement a robot that performs
phototaxis while avoiding collisions with obstacles. Once reached the black
spot under the light, it should halt. This set of behaviours should be
implemented by means of a \textbf{subsumption architecture}. A set of
``competences'' should then be defined, and place them in a hierarchical,
layered architecture.

\subsection{Designing the Subsumption Architecture}\label{ssec:subsum}

The subsumption architecture is shown in \Cref{fig:sub-arch}. The layers are
placed in way that, when control is taken by an upper layer, it inhibits every
other underlying layer. Each layer can then use lower layers in order to
communicate or use the latter's information in order to implement higher-level
behaviours.
The \emph{competences} developed are the following (listed from lower to higher level):
%
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth]{figures/sub-arch.jpg}
    \caption{The Subsumption Architecture for archiving phototaxis while
        avoiding collisions and halting when under the light and over the black
        spot.}
    \label{fig:sub-arch}
\end{figure}
%
\begin{enumerate}
    \item \emph{Control Wheels} lets the definition of the simplest behaviour
        in order to control robot's wheels. It accepts a left and right
        velocities and sets the wheel velocities accordingly. It also avoid
        that the max speed of robot's wheels doesn't exceed $15^{-2}m/s$.
    \item \emph{Go Forward} defines a simple competence for moving forward,
        making use of its lower layer.
    \item \emph{Turn} accepts a direction on which the robot should turn to.
        Left or right turns are performed by multiplying current opposite wheel
        velocity by a factor (\texttt{TURN\_RATIO=3}) and the other wheel velocity by zero.
        This will let the robot to turn more gradually for finer turns.
    \item \emph{Random Walk} this competence performs a sub-optimal random walk by changing
        every $n$ steps robot wheels velocities randomly chosen.
    \item \emph{Follow Light}: phototaxis implementation. It picks maximum
        light value detected from sensors with the usual neighbour weighted
        average, and chose the direction to turn to based on which sensor
        yielded the maximum value.
    \item \emph{Avoid Front Obstacles}: collision avoidance implementation,
        with a difference that only front sensors are used for detecting
        collisions. If obstacles are detected, the controller checks collision
        for left, right and down, in this order. The first of these directions
        that does not contain an obstacle is used to perform a turn.
    \item \emph{Halt on Stop}: leveraging ground sensors, if any of those four
        detects that the robot is on the black spot, wheel velocities are set
        to zero.
\end{enumerate}
Having defined each layer and their dependencies, in order to keep the
``centralised'' piece of code as simple as possible, every layer makes use of a
shared boolean variable named \texttt{CONTROL\_TAKEN} which is reset at each
step. All layer includes the necessary checks for the shared variable before
performing their task. If they can take control, they set the variable to true,
if not, they early return.

With this approach we can archive coordination without complicating too much
the code, while keeping in mind that global state/variables can lead to
potential bugs and are sometimes discouraged. Another consideration that can be
made with shared variables in a distributed architecture like the subsumption
architecture, is that this can lead to race conditions, which can be easily
mitigated by means of mutex variables or atomic primitives (in this case an
atomic boolean).

\bigskip
With this approach, the control flow executes each layer in a top down fashion,
from the higher level to the lowest, and thanks to the shared state there is no
need of centralised coordination or inhibition by the main control flow.

\subsection{Testing}
In the following section there will be illustrated some testing results similar
to what have been done in the \Cref{ssec:l2-test}.
\Cref{tab:simulation-results-sub} summarise tests results. Except for some
outliers, the subsumption architecture seem to be very similar across different
runs on the same arena rather than the control software developed for the lab
activiry two. The main reason behind this is that the logic for collision
avoidance for going always to the left influences a lot every simulation,
especially for all those cases where the robot can see the light in a very low
number of steps. When it comes to failures (cannot reach halting spot) in arena
3 and 4, it is worth adding that the robot stuck in narrow block
configurations: in fact, it does not detect any obstacles on front, it sees the
light but cannot move due to walls collision on left and right. This is also
the case for almost all runs (except the last one) of the arena 2. A better
collision avoidance approach could be developed, which takes into account also
collisions/potential collisions on left and right sides of the robot in order
to avoid entering narrow paths.

\begin{table}[ht]
\centering
\begin{tabular}{c|cc|cc|cc|cc}
\textbf{Run} & \multicolumn{2}{c|}{\textbf{Arena 1} (631098)} & \multicolumn{2}{c|}{\textbf{Arena 2} (859511)} & \multicolumn{2}{c|}{\textbf{Arena 3} (446461)} & \multicolumn{2}{c}{\textbf{Arena 4} (969235)} \\
 & Score & Seed & Score & Seed & Score & Seed & Score & Seed \\
\hline
1 & 922 & 367625 & \textcolor{blue}{3.032} & 072013 & \textcolor{blue}{1.283} & 377973 & 870 & 382322 \\
2 & 951 & 922560 & \textcolor{blue}{3.139} & 837462 & \textcolor{blue}{0.712} & 632701 & 860 & 265938 \\
3 & 937 & 904607 & \textcolor{blue}{3.086} & 723220 & 827 & 998607 & \textcolor{blue}{2.128} & 183737 \\
4 & 968 & 242114 & \textcolor{blue}{3.098} & 572212 & 891 & 748480 & 910 & 369984 \\
5 & 970 & 388548 & \textcolor{blue}{4.180} & 661765 & 830 & 588261 & 883 & 808043 \\
\end{tabular}
\caption{Simulation results on 1000 steps runs: integer scores indicate then
    number of steps in order to reach the light; floating-point scores (in
    \textcolor{blue}{blue}) indicate that the footbot could not reach the light
    in 1000 steps and records the minimum euclidean distance reached from the
    light. In column header, inside parenthesis are contained random seeds
    (argos) in order to produce the arena and robot placement. The seed column for
    each run determines the random seed used in the control software (re-generated
    at each reset).}
\label{tab:simulation-results-sub}
\end{table}
